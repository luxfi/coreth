---
title: Warp Messaging
description: Cross-subnet communication with BLS signature aggregation
---

# Warp Messaging

Warp is Lux's native cross-subnet messaging protocol. It enables secure communication between subnets using BLS signature aggregation, allowing smart contracts on different subnets to interact trustlessly.

## Overview

Warp messaging provides:

- **Cross-Subnet Communication**: Send messages between any Lux subnets
- **BLS Aggregation**: Efficient signature aggregation for validator attestation
- **Trustless Verification**: On-chain verification without external bridges
- **Arbitrary Payloads**: Send any data, not just asset transfers

## Architecture

```
Subnet A                          Subnet B
+------------------+             +------------------+
| Source Contract  |             | Dest Contract    |
|    sendWarp()    |             |  receiveWarp()   |
+--------+---------+             +--------+---------+
         |                                ^
         v                                |
+------------------+             +------------------+
| Warp Precompile  |             | Warp Precompile  |
|   (0x16201)      |             |   (0x16201)      |
+--------+---------+             +--------+---------+
         |                                ^
         v                                |
+------------------+             +------------------+
|   Validators     |  -------->  |   Validators     |
|   Sign Message   |  Aggregate  |   Verify Sigs    |
+------------------+             +------------------+
```

## Warp Precompile

The Warp precompile is deployed at address `0x16201` (LP-aligned: P=6 Bridges, C=2 C-Chain, II=01).

### Interface

```solidity
interface IWarpMessenger {
    // Emitted when a Warp message is sent
    event SendWarpMessage(
        address indexed sender,
        bytes32 indexed messageID,
        bytes message
    );

    // Send a Warp message
    function sendWarpMessage(
        bytes calldata payload
    ) external returns (bytes32 messageID);

    // Get verified Warp message from transaction's access list
    function getVerifiedWarpMessage(
        uint32 index
    ) external view returns (
        WarpMessage memory message,
        bool valid
    );

    // Get verified block hash from another chain
    function getVerifiedWarpBlockHash(
        uint32 index
    ) external view returns (
        WarpBlockHash memory blockHash,
        bool valid
    );

    // Get this chain's blockchain ID
    function getBlockchainID() external view returns (bytes32);
}

struct WarpMessage {
    bytes32 sourceChainID;
    address originSenderAddress;
    bytes payload;
}

struct WarpBlockHash {
    bytes32 sourceChainID;
    bytes32 blockHash;
}
```

## Sending Messages

### From Solidity

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IWarpMessenger {
    function sendWarpMessage(bytes calldata payload) external returns (bytes32);
    function getBlockchainID() external view returns (bytes32);
}

contract WarpSender {
    // LP-aligned: P=6 (Bridges), C=2 (C-Chain), II=01 (Warp)
    IWarpMessenger constant WARP = IWarpMessenger(
        0x0000000000000000000000000000000000016201
    );

    event MessageSent(bytes32 indexed messageID, bytes payload);

    function sendMessage(bytes calldata payload) external returns (bytes32) {
        bytes32 messageID = WARP.sendWarpMessage(payload);
        emit MessageSent(messageID, payload);
        return messageID;
    }

    function getChainID() external view returns (bytes32) {
        return WARP.getBlockchainID();
    }
}
```

### Message Structure

Warp messages contain:

```
+------------------+
| Source Chain ID  | 32 bytes
+------------------+
| Origin Address   | 20 bytes
+------------------+
| Payload          | Variable
+------------------+
```

## Receiving Messages

### Verification Flow

1. Relayer fetches message signatures from source subnet validators
2. Relayer aggregates signatures meeting quorum threshold
3. Relayer submits transaction with signed message in access list
4. Destination contract calls `getVerifiedWarpMessage()`
5. Precompile verifies BLS aggregate signature
6. Contract processes verified payload

### From Solidity

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IWarpMessenger {
    function getVerifiedWarpMessage(uint32 index) external view returns (
        WarpMessage memory message,
        bool valid
    );
}

struct WarpMessage {
    bytes32 sourceChainID;
    address originSenderAddress;
    bytes payload;
}

contract WarpReceiver {
    // LP-aligned: P=6 (Bridges), C=2 (C-Chain), II=01 (Warp)
    IWarpMessenger constant WARP = IWarpMessenger(
        0x0000000000000000000000000000000000016201
    );

    bytes32 public immutable trustedSourceChain;
    address public immutable trustedSender;

    constructor(bytes32 _sourceChain, address _sender) {
        trustedSourceChain = _sourceChain;
        trustedSender = _sender;
    }

    function receiveMessage() external {
        (WarpMessage memory message, bool valid) = WARP.getVerifiedWarpMessage(0);

        require(valid, "Invalid Warp message");
        require(message.sourceChainID == trustedSourceChain, "Untrusted source");
        require(message.originSenderAddress == trustedSender, "Untrusted sender");

        // Process payload
        _handlePayload(message.payload);
    }

    function _handlePayload(bytes memory payload) internal {
        // Application-specific logic
    }
}
```

## Signature Aggregation

### BLS Signatures

Warp uses BLS12-381 signatures for efficient aggregation:

- Validators sign messages with their BLS private keys
- Multiple signatures aggregate into a single signature
- Verification cost is constant regardless of signer count

### Quorum Requirements

Default quorum: 67% of subnet stake must sign.

Configurable in genesis:

```json
{
  "config": {
    "warpConfig": {
      "blockTimestamp": 0,
      "quorumNumerator": 67
    }
  }
}
```

### Aggregation Process

```typescript
// Fetch signatures from validators
const signatures = await Promise.all(
  validators.map(v => fetchSignature(v, messageID))
);

// Filter valid signatures
const validSigs = signatures.filter(s => s !== null);

// Check quorum
const stakeSum = validSigs.reduce((sum, s) => sum + s.stake, 0n);
if (stakeSum < totalStake * 67n / 100n) {
  throw new Error('Insufficient quorum');
}

// Aggregate
const aggregatedSig = aggregateBLS(validSigs.map(s => s.signature));
```

## Warp API

### warp_getMessageSignature

Get validator signature for a message:

```bash
curl -X POST -H "Content-Type: application/json" --data '{
  "jsonrpc": "2.0",
  "method": "warp_getMessageSignature",
  "params": {
    "messageID": "0x..."
  },
  "id": 1
}' http://localhost:9650/ext/bc/C/rpc
```

### warp_getBlockSignature

Get validator signature for a block hash:

```bash
curl -X POST -H "Content-Type: application/json" --data '{
  "jsonrpc": "2.0",
  "method": "warp_getBlockSignature",
  "params": {
    "blockID": "0x..."
  },
  "id": 1
}' http://localhost:9650/ext/bc/C/rpc
```

### warp_getMessageAggregateSignature

Get aggregated signature for a message:

```bash
curl -X POST -H "Content-Type: application/json" --data '{
  "jsonrpc": "2.0",
  "method": "warp_getMessageAggregateSignature",
  "params": {
    "messageID": "0x...",
    "quorumNum": 67,
    "subnetID": "..."
  },
  "id": 1
}' http://localhost:9650/ext/bc/C/rpc
```

## Relayer

A relayer watches for Warp messages and delivers them to destination chains.

### Basic Relayer

```typescript
class WarpRelayer {
  async relayMessage(
    sourceRPC: string,
    destRPC: string,
    messageID: string
  ) {
    // 1. Get aggregated signature
    const signedMessage = await this.getAggregatedSignature(
      sourceRPC,
      messageID
    );

    // 2. Build delivery transaction
    const tx = await this.buildDeliveryTx(destRPC, signedMessage);

    // 3. Submit transaction
    const receipt = await this.submitTx(destRPC, tx);

    return receipt;
  }

  async getAggregatedSignature(rpc: string, messageID: string) {
    const response = await fetch(rpc, {
      method: 'POST',
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'warp_getMessageAggregateSignature',
        params: { messageID, quorumNum: 67 },
        id: 1
      })
    });
    return response.json();
  }
}
```

### Access List Encoding

Signed Warp messages are passed via EIP-2930 access lists:

```typescript
const tx = {
  to: receiverContract,
  data: receiverInterface.encodeFunctionData('receiveMessage'),
  accessList: [
    {
      address: WARP_PRECOMPILE,
      storageKeys: [
        encodeWarpMessage(signedMessage)
      ]
    }
  ]
};
```

## Use Cases

### Cross-Subnet Token Bridge

```solidity
contract WarpBridge {
    function bridgeTokens(
        bytes32 destChain,
        address destBridge,
        address token,
        uint256 amount
    ) external {
        IERC20(token).transferFrom(msg.sender, address(this), amount);

        bytes memory payload = abi.encode(
            msg.sender,
            token,
            amount
        );

        WARP.sendWarpMessage(payload);
    }

    function claimTokens() external {
        (WarpMessage memory msg, bool valid) = WARP.getVerifiedWarpMessage(0);
        require(valid);

        (address recipient, address token, uint256 amount) =
            abi.decode(msg.payload, (address, address, uint256));

        IERC20(token).transfer(recipient, amount);
    }
}
```

### Cross-Subnet Governance

```solidity
contract CrossSubnetGovernance {
    function executeProposal(bytes32 proposalID) external {
        (WarpMessage memory msg, bool valid) = WARP.getVerifiedWarpMessage(0);
        require(valid);
        require(msg.sourceChainID == GOVERNANCE_CHAIN);

        (bytes32 id, bytes memory action) = abi.decode(msg.payload, (bytes32, bytes));
        require(id == proposalID);

        // Execute governance action
        _execute(action);
    }
}
```

### Oracle Data Feed

```solidity
contract WarpOracle {
    function updatePrice(bytes32 asset) external {
        (WarpMessage memory msg, bool valid) = WARP.getVerifiedWarpMessage(0);
        require(valid);
        require(msg.sourceChainID == ORACLE_CHAIN);

        (bytes32 assetID, uint256 price, uint256 timestamp) =
            abi.decode(msg.payload, (bytes32, uint256, uint256));

        require(assetID == asset);
        prices[asset] = Price(price, timestamp);
    }
}
```

## Security

### Source Verification

Always verify:
1. `sourceChainID` matches expected source
2. `originSenderAddress` is trusted contract
3. Payload structure is valid

### Replay Protection

Messages include unique IDs. Track processed messages:

```solidity
mapping(bytes32 => bool) public processedMessages;

function receive() external {
    (WarpMessage memory msg, bool valid) = WARP.getVerifiedWarpMessage(0);
    bytes32 msgHash = keccak256(abi.encode(msg));

    require(!processedMessages[msgHash], "Already processed");
    processedMessages[msgHash] = true;

    // Process message
}
```

### Quorum Considerations

Higher quorum = more security but slower finality. Default 67% provides Byzantine fault tolerance assuming < 1/3 malicious stake.
